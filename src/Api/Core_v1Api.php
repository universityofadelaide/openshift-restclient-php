<?php
/**
 * Core_v1Api
 * PHP version 5
 *
 * @category Class
 * @package  UniversityOfAdelaide\OpenShift
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * OpenShift API (with Kubernetes)
 *
 * OpenShift provides builds, application lifecycle, image content management, and administrative policy on top of Kubernetes. The API allows consistent management of those objects.  All API operations are authenticated via an Authorization bearer token that is provided for service accounts as a generated secret (in JWT form) or via the native OAuth endpoint located at /oauth/authorize. Core infrastructure components may use client certificates that require no authentication.  All API operations return a 'resourceVersion' string that represents the version of the object in the underlying storage. The standard LIST operation performs a snapshot read of the underlying objects, returning a resourceVersion representing a consistent version of the listed objects. The WATCH operation allows all updates to a set of objects after the provided resourceVersion to be observed by a client. By listing and beginning a watch from the returned resourceVersion, clients may observe a consistent view of the state of one or more objects. Note that WATCH always returns the update after the provided resourceVersion. Watch may be extended a limited time in the past - using etcd 2 the watch window is 1000 events (which on a large cluster may only be a few tens of seconds) so clients must explicitly handle the \"watch to old error\" by re-listing.  Objects are divided into two rough categories - those that have a lifecycle and must reflect the state of the cluster, and those that have no state. Objects with lifecycle typically have three main sections:  * 'metadata' common to all objects * a 'spec' that represents the desired state * a 'status' that represents how much of the desired state is reflected on   the cluster at the current time  Objects that have no state have 'metadata' but may lack a 'spec' or 'status' section.  Objects are divided into those that are namespace scoped (only exist inside of a namespace) and those that are cluster scoped (exist outside of a namespace). A namespace scoped resource will be deleted when the namespace is deleted and cannot be created if the namespace has not yet been created or is in the process of deletion. Cluster scoped resources are typically only accessible to admins - resources like nodes, persistent volumes, and cluster policy.  All objects have a schema that is a combination of the 'kind' and 'apiVersion' fields. This schema is additive only for any given version - no backwards incompatible changes are allowed without incrementing the apiVersion. The server will return and accept a number of standard responses that share a common schema - for instance, the common error type is 'metav1.Status' (described below) and will be returned on any error from the API server.  The API is available in multiple serialization formats - the default is JSON (Accept: application/json and Content-Type: application/json) but clients may also use YAML (application/yaml) or the native Protobuf schema (application/vnd.kubernetes.protobuf). Note that the format of the WATCH API call is slightly different - for JSON it returns newline delimited objects while for Protobuf it returns length-delimited frames (4 bytes in network-order) that contain a 'versioned.Watch' Protobuf object.  See the OpenShift documentation at https://docs.openshift.org for more information.
 *
 * OpenAPI spec version: latest
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace UniversityOfAdelaide\OpenShift\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use UniversityOfAdelaide\OpenShift\ApiException;
use UniversityOfAdelaide\OpenShift\Configuration;
use UniversityOfAdelaide\OpenShift\HeaderSelector;
use UniversityOfAdelaide\OpenShift\ObjectSerializer;

/**
 * Core_v1Api Class Doc Comment
 *
 * @category Class
 * @package  UniversityOfAdelaide\OpenShift
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Core_v1Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration $config
     * @param HeaderSelector $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation connectCoreV1DeleteNamespacedPodProxy
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1DeleteNamespacedPodProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1DeleteNamespacedPodProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1DeleteNamespacedPodProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1DeleteNamespacedPodProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1DeleteNamespacedPodProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1DeleteNamespacedPodProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1DeleteNamespacedPodProxyWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1DeleteNamespacedPodProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1DeleteNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1DeleteNamespacedPodProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1DeleteNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1DeleteNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1DeleteNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1DeleteNamespacedPodProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1DeleteNamespacedServiceProxy
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1DeleteNamespacedServiceProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1DeleteNamespacedServiceProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1DeleteNamespacedServiceProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1DeleteNamespacedServiceProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1DeleteNamespacedServiceProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1DeleteNamespacedServiceProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1DeleteNamespacedServiceProxyWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1DeleteNamespacedServiceProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1DeleteNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1DeleteNamespacedServiceProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1DeleteNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1DeleteNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1DeleteNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1DeleteNamespacedServiceProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1DeleteNodeProxy
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1DeleteNodeProxy($name, $path = null)
    {
        list($response) = $this->connectCoreV1DeleteNodeProxyWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1DeleteNodeProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1DeleteNodeProxyWithHttpInfo($name, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1DeleteNodeProxy');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1DeleteNodeProxyWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1DeleteNodeProxyWithPath($name, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1DeleteNodeProxyWithPathWithHttpInfo($name, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1DeleteNodeProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1DeleteNodeProxyWithPathWithHttpInfo($name, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1DeleteNodeProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1DeleteNodeProxyWithPath');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1GetNamespacedPodAttach
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $container The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
     * @param bool $stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)
     * @param bool $stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)
     * @param bool $stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)
     * @param bool $tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1GetNamespacedPodAttach($name, $namespace, $container = null, $stderr = null, $stdin = null, $stdout = null, $tty = null)
    {
        list($response) = $this->connectCoreV1GetNamespacedPodAttachWithHttpInfo($name, $namespace, $container, $stderr, $stdin, $stdout, $tty);
        return $response;
    }

    /**
     * Operation connectCoreV1GetNamespacedPodAttachWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $container The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
     * @param bool $stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)
     * @param bool $stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)
     * @param bool $stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)
     * @param bool $tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1GetNamespacedPodAttachWithHttpInfo($name, $namespace, $container = null, $stderr = null, $stdin = null, $stdout = null, $tty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1GetNamespacedPodAttach');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1GetNamespacedPodAttach');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/attach';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($container !== null) {
            $queryParams['container'] = ObjectSerializer::toQueryValue($container);
        }
        // query params
        if ($stderr !== null) {
            $queryParams['stderr'] = ObjectSerializer::toQueryValue($stderr);
        }
        // query params
        if ($stdin !== null) {
            $queryParams['stdin'] = ObjectSerializer::toQueryValue($stdin);
        }
        // query params
        if ($stdout !== null) {
            $queryParams['stdout'] = ObjectSerializer::toQueryValue($stdout);
        }
        // query params
        if ($tty !== null) {
            $queryParams['tty'] = ObjectSerializer::toQueryValue($tty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1GetNamespacedPodExec
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $command Command is the remote command to execute. argv array. Not executed within a shell. (optional)
     * @param string $container Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
     * @param bool $stderr Redirect the standard error stream of the pod for this call. Defaults to true. (optional)
     * @param bool $stdin Redirect the standard input stream of the pod for this call. Defaults to false. (optional)
     * @param bool $stdout Redirect the standard output stream of the pod for this call. Defaults to true. (optional)
     * @param bool $tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1GetNamespacedPodExec($name, $namespace, $command = null, $container = null, $stderr = null, $stdin = null, $stdout = null, $tty = null)
    {
        list($response) = $this->connectCoreV1GetNamespacedPodExecWithHttpInfo($name, $namespace, $command, $container, $stderr, $stdin, $stdout, $tty);
        return $response;
    }

    /**
     * Operation connectCoreV1GetNamespacedPodExecWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $command Command is the remote command to execute. argv array. Not executed within a shell. (optional)
     * @param string $container Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
     * @param bool $stderr Redirect the standard error stream of the pod for this call. Defaults to true. (optional)
     * @param bool $stdin Redirect the standard input stream of the pod for this call. Defaults to false. (optional)
     * @param bool $stdout Redirect the standard output stream of the pod for this call. Defaults to true. (optional)
     * @param bool $tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1GetNamespacedPodExecWithHttpInfo($name, $namespace, $command = null, $container = null, $stderr = null, $stdin = null, $stdout = null, $tty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1GetNamespacedPodExec');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1GetNamespacedPodExec');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/exec';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($command !== null) {
            $queryParams['command'] = ObjectSerializer::toQueryValue($command);
        }
        // query params
        if ($container !== null) {
            $queryParams['container'] = ObjectSerializer::toQueryValue($container);
        }
        // query params
        if ($stderr !== null) {
            $queryParams['stderr'] = ObjectSerializer::toQueryValue($stderr);
        }
        // query params
        if ($stdin !== null) {
            $queryParams['stdin'] = ObjectSerializer::toQueryValue($stdin);
        }
        // query params
        if ($stdout !== null) {
            $queryParams['stdout'] = ObjectSerializer::toQueryValue($stdout);
        }
        // query params
        if ($tty !== null) {
            $queryParams['tty'] = ObjectSerializer::toQueryValue($tty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1GetNamespacedPodPortforward
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param int $ports List of ports to forward Required when using WebSockets (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1GetNamespacedPodPortforward($name, $namespace, $ports = null)
    {
        list($response) = $this->connectCoreV1GetNamespacedPodPortforwardWithHttpInfo($name, $namespace, $ports);
        return $response;
    }

    /**
     * Operation connectCoreV1GetNamespacedPodPortforwardWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param int $ports List of ports to forward Required when using WebSockets (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1GetNamespacedPodPortforwardWithHttpInfo($name, $namespace, $ports = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1GetNamespacedPodPortforward');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1GetNamespacedPodPortforward');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/portforward';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($ports !== null) {
            $queryParams['ports'] = ObjectSerializer::toQueryValue($ports);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1GetNamespacedPodProxy
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1GetNamespacedPodProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1GetNamespacedPodProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1GetNamespacedPodProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1GetNamespacedPodProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1GetNamespacedPodProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1GetNamespacedPodProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1GetNamespacedPodProxyWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1GetNamespacedPodProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1GetNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1GetNamespacedPodProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1GetNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1GetNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1GetNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1GetNamespacedPodProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1GetNamespacedServiceProxy
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1GetNamespacedServiceProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1GetNamespacedServiceProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1GetNamespacedServiceProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1GetNamespacedServiceProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1GetNamespacedServiceProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1GetNamespacedServiceProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1GetNamespacedServiceProxyWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1GetNamespacedServiceProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1GetNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1GetNamespacedServiceProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1GetNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1GetNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1GetNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1GetNamespacedServiceProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1GetNodeProxy
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1GetNodeProxy($name, $path = null)
    {
        list($response) = $this->connectCoreV1GetNodeProxyWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1GetNodeProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1GetNodeProxyWithHttpInfo($name, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1GetNodeProxy');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1GetNodeProxyWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1GetNodeProxyWithPath($name, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1GetNodeProxyWithPathWithHttpInfo($name, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1GetNodeProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1GetNodeProxyWithPathWithHttpInfo($name, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1GetNodeProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1GetNodeProxyWithPath');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1HeadNamespacedPodProxy
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1HeadNamespacedPodProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1HeadNamespacedPodProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1HeadNamespacedPodProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1HeadNamespacedPodProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1HeadNamespacedPodProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1HeadNamespacedPodProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1HeadNamespacedPodProxyWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1HeadNamespacedPodProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1HeadNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1HeadNamespacedPodProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1HeadNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1HeadNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1HeadNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1HeadNamespacedPodProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1HeadNamespacedServiceProxy
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1HeadNamespacedServiceProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1HeadNamespacedServiceProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1HeadNamespacedServiceProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1HeadNamespacedServiceProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1HeadNamespacedServiceProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1HeadNamespacedServiceProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1HeadNamespacedServiceProxyWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1HeadNamespacedServiceProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1HeadNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1HeadNamespacedServiceProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1HeadNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1HeadNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1HeadNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1HeadNamespacedServiceProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1HeadNodeProxy
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1HeadNodeProxy($name, $path = null)
    {
        list($response) = $this->connectCoreV1HeadNodeProxyWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1HeadNodeProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1HeadNodeProxyWithHttpInfo($name, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1HeadNodeProxy');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1HeadNodeProxyWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1HeadNodeProxyWithPath($name, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1HeadNodeProxyWithPathWithHttpInfo($name, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1HeadNodeProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1HeadNodeProxyWithPathWithHttpInfo($name, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1HeadNodeProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1HeadNodeProxyWithPath');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1OptionsNamespacedPodProxy
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1OptionsNamespacedPodProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1OptionsNamespacedPodProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1OptionsNamespacedPodProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1OptionsNamespacedPodProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1OptionsNamespacedPodProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1OptionsNamespacedPodProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1OptionsNamespacedPodProxyWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1OptionsNamespacedPodProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1OptionsNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1OptionsNamespacedPodProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1OptionsNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1OptionsNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1OptionsNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1OptionsNamespacedPodProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1OptionsNamespacedServiceProxy
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1OptionsNamespacedServiceProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1OptionsNamespacedServiceProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1OptionsNamespacedServiceProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1OptionsNamespacedServiceProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1OptionsNamespacedServiceProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1OptionsNamespacedServiceProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1OptionsNamespacedServiceProxyWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1OptionsNamespacedServiceProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1OptionsNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1OptionsNamespacedServiceProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1OptionsNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1OptionsNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1OptionsNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1OptionsNamespacedServiceProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1OptionsNodeProxy
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1OptionsNodeProxy($name, $path = null)
    {
        list($response) = $this->connectCoreV1OptionsNodeProxyWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1OptionsNodeProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1OptionsNodeProxyWithHttpInfo($name, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1OptionsNodeProxy');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1OptionsNodeProxyWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1OptionsNodeProxyWithPath($name, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1OptionsNodeProxyWithPathWithHttpInfo($name, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1OptionsNodeProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1OptionsNodeProxyWithPathWithHttpInfo($name, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1OptionsNodeProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1OptionsNodeProxyWithPath');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PostNamespacedPodAttach
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $container The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
     * @param bool $stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)
     * @param bool $stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)
     * @param bool $stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)
     * @param bool $tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PostNamespacedPodAttach($name, $namespace, $container = null, $stderr = null, $stdin = null, $stdout = null, $tty = null)
    {
        list($response) = $this->connectCoreV1PostNamespacedPodAttachWithHttpInfo($name, $namespace, $container, $stderr, $stdin, $stdout, $tty);
        return $response;
    }

    /**
     * Operation connectCoreV1PostNamespacedPodAttachWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $container The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
     * @param bool $stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)
     * @param bool $stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)
     * @param bool $stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)
     * @param bool $tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PostNamespacedPodAttachWithHttpInfo($name, $namespace, $container = null, $stderr = null, $stdin = null, $stdout = null, $tty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PostNamespacedPodAttach');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PostNamespacedPodAttach');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/attach';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($container !== null) {
            $queryParams['container'] = ObjectSerializer::toQueryValue($container);
        }
        // query params
        if ($stderr !== null) {
            $queryParams['stderr'] = ObjectSerializer::toQueryValue($stderr);
        }
        // query params
        if ($stdin !== null) {
            $queryParams['stdin'] = ObjectSerializer::toQueryValue($stdin);
        }
        // query params
        if ($stdout !== null) {
            $queryParams['stdout'] = ObjectSerializer::toQueryValue($stdout);
        }
        // query params
        if ($tty !== null) {
            $queryParams['tty'] = ObjectSerializer::toQueryValue($tty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PostNamespacedPodExec
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $command Command is the remote command to execute. argv array. Not executed within a shell. (optional)
     * @param string $container Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
     * @param bool $stderr Redirect the standard error stream of the pod for this call. Defaults to true. (optional)
     * @param bool $stdin Redirect the standard input stream of the pod for this call. Defaults to false. (optional)
     * @param bool $stdout Redirect the standard output stream of the pod for this call. Defaults to true. (optional)
     * @param bool $tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PostNamespacedPodExec($name, $namespace, $command = null, $container = null, $stderr = null, $stdin = null, $stdout = null, $tty = null)
    {
        list($response) = $this->connectCoreV1PostNamespacedPodExecWithHttpInfo($name, $namespace, $command, $container, $stderr, $stdin, $stdout, $tty);
        return $response;
    }

    /**
     * Operation connectCoreV1PostNamespacedPodExecWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $command Command is the remote command to execute. argv array. Not executed within a shell. (optional)
     * @param string $container Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
     * @param bool $stderr Redirect the standard error stream of the pod for this call. Defaults to true. (optional)
     * @param bool $stdin Redirect the standard input stream of the pod for this call. Defaults to false. (optional)
     * @param bool $stdout Redirect the standard output stream of the pod for this call. Defaults to true. (optional)
     * @param bool $tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PostNamespacedPodExecWithHttpInfo($name, $namespace, $command = null, $container = null, $stderr = null, $stdin = null, $stdout = null, $tty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PostNamespacedPodExec');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PostNamespacedPodExec');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/exec';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($command !== null) {
            $queryParams['command'] = ObjectSerializer::toQueryValue($command);
        }
        // query params
        if ($container !== null) {
            $queryParams['container'] = ObjectSerializer::toQueryValue($container);
        }
        // query params
        if ($stderr !== null) {
            $queryParams['stderr'] = ObjectSerializer::toQueryValue($stderr);
        }
        // query params
        if ($stdin !== null) {
            $queryParams['stdin'] = ObjectSerializer::toQueryValue($stdin);
        }
        // query params
        if ($stdout !== null) {
            $queryParams['stdout'] = ObjectSerializer::toQueryValue($stdout);
        }
        // query params
        if ($tty !== null) {
            $queryParams['tty'] = ObjectSerializer::toQueryValue($tty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PostNamespacedPodPortforward
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param int $ports List of ports to forward Required when using WebSockets (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PostNamespacedPodPortforward($name, $namespace, $ports = null)
    {
        list($response) = $this->connectCoreV1PostNamespacedPodPortforwardWithHttpInfo($name, $namespace, $ports);
        return $response;
    }

    /**
     * Operation connectCoreV1PostNamespacedPodPortforwardWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param int $ports List of ports to forward Required when using WebSockets (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PostNamespacedPodPortforwardWithHttpInfo($name, $namespace, $ports = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PostNamespacedPodPortforward');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PostNamespacedPodPortforward');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/portforward';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($ports !== null) {
            $queryParams['ports'] = ObjectSerializer::toQueryValue($ports);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PostNamespacedPodProxy
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PostNamespacedPodProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1PostNamespacedPodProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1PostNamespacedPodProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PostNamespacedPodProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PostNamespacedPodProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PostNamespacedPodProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PostNamespacedPodProxyWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PostNamespacedPodProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1PostNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1PostNamespacedPodProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PostNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PostNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PostNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1PostNamespacedPodProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PostNamespacedServiceProxy
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PostNamespacedServiceProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1PostNamespacedServiceProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1PostNamespacedServiceProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PostNamespacedServiceProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PostNamespacedServiceProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PostNamespacedServiceProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PostNamespacedServiceProxyWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PostNamespacedServiceProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1PostNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1PostNamespacedServiceProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PostNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PostNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PostNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1PostNamespacedServiceProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PostNodeProxy
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PostNodeProxy($name, $path = null)
    {
        list($response) = $this->connectCoreV1PostNodeProxyWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1PostNodeProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PostNodeProxyWithHttpInfo($name, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PostNodeProxy');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PostNodeProxyWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PostNodeProxyWithPath($name, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1PostNodeProxyWithPathWithHttpInfo($name, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1PostNodeProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PostNodeProxyWithPathWithHttpInfo($name, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PostNodeProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1PostNodeProxyWithPath');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PutNamespacedPodProxy
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PutNamespacedPodProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1PutNamespacedPodProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1PutNamespacedPodProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PutNamespacedPodProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PutNamespacedPodProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PutNamespacedPodProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PutNamespacedPodProxyWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PutNamespacedPodProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1PutNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1PutNamespacedPodProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PutNamespacedPodProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PutNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PutNamespacedPodProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1PutNamespacedPodProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PutNamespacedServiceProxy
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PutNamespacedServiceProxy($name, $namespace, $path = null)
    {
        list($response) = $this->connectCoreV1PutNamespacedServiceProxyWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1PutNamespacedServiceProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PutNamespacedServiceProxyWithHttpInfo($name, $namespace, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PutNamespacedServiceProxy');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PutNamespacedServiceProxy');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PutNamespacedServiceProxyWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PutNamespacedServiceProxyWithPath($name, $namespace, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1PutNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1PutNamespacedServiceProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PutNamespacedServiceProxyWithPathWithHttpInfo($name, $namespace, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PutNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling connectCoreV1PutNamespacedServiceProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1PutNamespacedServiceProxyWithPath');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PutNodeProxy
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PutNodeProxy($name, $path = null)
    {
        list($response) = $this->connectCoreV1PutNodeProxyWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation connectCoreV1PutNodeProxyWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PutNodeProxyWithHttpInfo($name, $path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PutNodeProxy');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation connectCoreV1PutNodeProxyWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function connectCoreV1PutNodeProxyWithPath($name, $path, $path2 = null)
    {
        list($response) = $this->connectCoreV1PutNodeProxyWithPathWithHttpInfo($name, $path, $path2);
        return $response;
    }

    /**
     * Operation connectCoreV1PutNodeProxyWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectCoreV1PutNodeProxyWithPathWithHttpInfo($name, $path, $path2 = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling connectCoreV1PutNodeProxyWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling connectCoreV1PutNodeProxyWithPath');
        }

        $resourcePath = '/api/v1/nodes/{name}/proxy/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($path2 !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path2);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1BindingForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Binding $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Binding
     */
    public function createCoreV1BindingForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1BindingForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1BindingForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Binding $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Binding, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1BindingForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1BindingForAllNamespaces');
        }

        $resourcePath = '/api/v1/bindings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Binding';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Binding', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1ConfigMapForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap
     */
    public function createCoreV1ConfigMapForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1ConfigMapForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1ConfigMapForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1ConfigMapForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1ConfigMapForAllNamespaces');
        }

        $resourcePath = '/api/v1/configmaps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1EndpointsForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Endpoints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Endpoints
     */
    public function createCoreV1EndpointsForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1EndpointsForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1EndpointsForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Endpoints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Endpoints, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1EndpointsForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1EndpointsForAllNamespaces');
        }

        $resourcePath = '/api/v1/endpoints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1EventForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Event $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Event
     */
    public function createCoreV1EventForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1EventForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1EventForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Event $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Event, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1EventForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1EventForAllNamespaces');
        }

        $resourcePath = '/api/v1/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Event';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Event', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1LimitRangeForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1LimitRange $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1LimitRange
     */
    public function createCoreV1LimitRangeForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1LimitRangeForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1LimitRangeForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1LimitRange $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1LimitRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1LimitRangeForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1LimitRangeForAllNamespaces');
        }

        $resourcePath = '/api/v1/limitranges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1Namespace
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Namespace $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Namespace
     */
    public function createCoreV1Namespace($body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespaceWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespaceWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Namespace $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Namespace, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespaceWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1Namespace');
        }

        $resourcePath = '/api/v1/namespaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Namespace';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Namespace', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedBinding
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Binding $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Binding
     */
    public function createCoreV1NamespacedBinding($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedBindingWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedBindingWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Binding $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Binding, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedBindingWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedBinding');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedBinding');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/bindings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Binding';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Binding', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedBindingBinding
     *
     * 
     *
     * @param string $name name of the Binding (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Binding $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Binding
     */
    public function createCoreV1NamespacedBindingBinding($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedBindingBindingWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedBindingBindingWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Binding (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Binding $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Binding, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedBindingBindingWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling createCoreV1NamespacedBindingBinding');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedBindingBinding');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedBindingBinding');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/binding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Binding';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Binding', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedConfigMap
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap
     */
    public function createCoreV1NamespacedConfigMap($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedConfigMapWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedConfigMapWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedConfigMapWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedConfigMap');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedConfigMap');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/configmaps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedEndpoints
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Endpoints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Endpoints
     */
    public function createCoreV1NamespacedEndpoints($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedEndpointsWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedEndpointsWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Endpoints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Endpoints, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedEndpointsWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedEndpoints');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedEndpoints');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/endpoints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedEvent
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Event $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Event
     */
    public function createCoreV1NamespacedEvent($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedEventWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedEventWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Event $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Event, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedEventWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedEvent');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedEvent');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Event';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Event', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedEvictionEviction
     *
     * 
     *
     * @param string $name name of the Eviction (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1beta1Eviction $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1beta1Eviction
     */
    public function createCoreV1NamespacedEvictionEviction($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedEvictionEvictionWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedEvictionEvictionWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Eviction (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1beta1Eviction $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1beta1Eviction, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedEvictionEvictionWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling createCoreV1NamespacedEvictionEviction');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedEvictionEviction');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedEvictionEviction');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/eviction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1beta1Eviction';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1beta1Eviction', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedLimitRange
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1LimitRange $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1LimitRange
     */
    public function createCoreV1NamespacedLimitRange($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedLimitRangeWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedLimitRangeWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1LimitRange $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1LimitRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedLimitRangeWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedLimitRange');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedLimitRange');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/limitranges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedPersistentVolumeClaim
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim
     */
    public function createCoreV1NamespacedPersistentVolumeClaim($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedPersistentVolumeClaimWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedPersistentVolumeClaim');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedPersistentVolumeClaim');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedPod
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Pod $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Pod
     */
    public function createCoreV1NamespacedPod($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedPodWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Pod $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Pod, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedPodWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedPod');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedPod');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Pod';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Pod', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedPodTemplate
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate
     */
    public function createCoreV1NamespacedPodTemplate($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedPodTemplateWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedPodTemplateWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedPodTemplateWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedPodTemplate');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedPodTemplate');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/podtemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedReplicationController
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController
     */
    public function createCoreV1NamespacedReplicationController($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedReplicationControllerWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedReplicationControllerWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedReplicationControllerWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedReplicationController');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedReplicationController');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedResourceQuota
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota
     */
    public function createCoreV1NamespacedResourceQuota($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedResourceQuotaWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedResourceQuotaWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedResourceQuotaWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedResourceQuota');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedResourceQuota');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedSecret
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Secret $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Secret
     */
    public function createCoreV1NamespacedSecret($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedSecretWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedSecretWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Secret $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Secret, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedSecretWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedSecret');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedSecret');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Secret';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Secret', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedService
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Service $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Service
     */
    public function createCoreV1NamespacedService($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedServiceWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Service $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedServiceWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedService');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedService');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Service';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Service', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1NamespacedServiceAccount
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount
     */
    public function createCoreV1NamespacedServiceAccount($namespace, $body, $pretty = null)
    {
        list($response) = $this->createCoreV1NamespacedServiceAccountWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NamespacedServiceAccountWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NamespacedServiceAccountWithHttpInfo($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling createCoreV1NamespacedServiceAccount');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1NamespacedServiceAccount');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/serviceaccounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1Node
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Node $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Node
     */
    public function createCoreV1Node($body, $pretty = null)
    {
        list($response) = $this->createCoreV1NodeWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1NodeWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Node $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1NodeWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1Node');
        }

        $resourcePath = '/api/v1/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Node';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Node', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1PersistentVolume
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume
     */
    public function createCoreV1PersistentVolume($body, $pretty = null)
    {
        list($response) = $this->createCoreV1PersistentVolumeWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1PersistentVolumeWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1PersistentVolumeWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1PersistentVolume');
        }

        $resourcePath = '/api/v1/persistentvolumes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1PersistentVolumeClaimForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim
     */
    public function createCoreV1PersistentVolumeClaimForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1PersistentVolumeClaimForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1PersistentVolumeClaimForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1PersistentVolumeClaimForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1PersistentVolumeClaimForAllNamespaces');
        }

        $resourcePath = '/api/v1/persistentvolumeclaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1PodForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Pod $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Pod
     */
    public function createCoreV1PodForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1PodForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1PodForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Pod $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Pod, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1PodForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1PodForAllNamespaces');
        }

        $resourcePath = '/api/v1/pods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Pod';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Pod', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1PodTemplateForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate
     */
    public function createCoreV1PodTemplateForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1PodTemplateForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1PodTemplateForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1PodTemplateForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1PodTemplateForAllNamespaces');
        }

        $resourcePath = '/api/v1/podtemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1ReplicationControllerForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController
     */
    public function createCoreV1ReplicationControllerForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1ReplicationControllerForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1ReplicationControllerForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1ReplicationControllerForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1ReplicationControllerForAllNamespaces');
        }

        $resourcePath = '/api/v1/replicationcontrollers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1ResourceQuotaForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota
     */
    public function createCoreV1ResourceQuotaForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1ResourceQuotaForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1ResourceQuotaForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1ResourceQuotaForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1ResourceQuotaForAllNamespaces');
        }

        $resourcePath = '/api/v1/resourcequotas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1SecretForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Secret $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Secret
     */
    public function createCoreV1SecretForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1SecretForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1SecretForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Secret $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Secret, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1SecretForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1SecretForAllNamespaces');
        }

        $resourcePath = '/api/v1/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Secret';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Secret', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1SecurityContextConstraints
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints
     */
    public function createCoreV1SecurityContextConstraints($body, $pretty = null)
    {
        list($response) = $this->createCoreV1SecurityContextConstraintsWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1SecurityContextConstraintsWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1SecurityContextConstraintsWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1SecurityContextConstraints');
        }

        $resourcePath = '/api/v1/securitycontextconstraints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1ServiceAccountForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount
     */
    public function createCoreV1ServiceAccountForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1ServiceAccountForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1ServiceAccountForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1ServiceAccountForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1ServiceAccountForAllNamespaces');
        }

        $resourcePath = '/api/v1/serviceaccounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation createCoreV1ServiceForAllNamespaces
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Service $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Service
     */
    public function createCoreV1ServiceForAllNamespaces($body, $pretty = null)
    {
        list($response) = $this->createCoreV1ServiceForAllNamespacesWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createCoreV1ServiceForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Service $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoreV1ServiceForAllNamespacesWithHttpInfo($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling createCoreV1ServiceForAllNamespaces');
        }

        $resourcePath = '/api/v1/services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Service';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Service', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespace
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespace($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespaceWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespaceWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespaceWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/namespaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedConfigMap
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedConfigMap($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedConfigMapWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedConfigMapWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedConfigMapWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedConfigMap');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/configmaps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedEndpoints
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedEndpoints($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedEndpointsWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedEndpointsWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedEndpointsWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedEndpoints');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/endpoints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedEvent
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedEvent($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedEventWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedEventWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedEventWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedEvent');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedLimitRange
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedLimitRange($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedLimitRangeWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedLimitRangeWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedLimitRangeWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedLimitRange');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/limitranges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedPersistentVolumeClaim
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedPersistentVolumeClaim($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedPersistentVolumeClaimWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedPersistentVolumeClaimWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedPersistentVolumeClaimWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedPersistentVolumeClaim');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedPod
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedPod($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedPodWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedPodWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedPod');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedPodTemplate
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedPodTemplate($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedPodTemplateWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedPodTemplateWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedPodTemplateWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedPodTemplate');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/podtemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedReplicationController
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedReplicationController($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedReplicationControllerWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedReplicationControllerWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedReplicationControllerWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedReplicationController');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedResourceQuota
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedResourceQuota($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedResourceQuotaWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedResourceQuotaWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedResourceQuotaWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedResourceQuota');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedSecret
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedSecret($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedSecretWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedSecretWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedSecretWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedSecret');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNamespacedServiceAccount
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNamespacedServiceAccount($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNamespacedServiceAccountWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNamespacedServiceAccountWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNamespacedServiceAccountWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1CollectionNamespacedServiceAccount');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/serviceaccounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionNode
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionNode($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionNodeWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionNodeWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionNodeWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionPersistentVolume
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionPersistentVolume($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionPersistentVolumeWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionPersistentVolumeWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionPersistentVolumeWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/persistentvolumes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1CollectionSecurityContextConstraints
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1CollectionSecurityContextConstraints($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->deleteCoreV1CollectionSecurityContextConstraintsWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCoreV1CollectionSecurityContextConstraintsWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1CollectionSecurityContextConstraintsWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/securitycontextconstraints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1Namespace
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1Namespace($name, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespaceWithHttpInfo($name, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespaceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespaceWithHttpInfo($name, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1Namespace');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1Namespace');
        }

        $resourcePath = '/api/v1/namespaces/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedConfigMap
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedConfigMap($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedConfigMapWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedConfigMap');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedConfigMap');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedConfigMap');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/configmaps/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedEndpoints
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedEndpoints($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedEndpointsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedEndpoints');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedEndpoints');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedEndpoints');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/endpoints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedEvent
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedEvent($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedEventWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedEventWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedEventWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedEvent');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedEvent');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedEvent');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/events/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedLimitRange
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedLimitRange($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedLimitRangeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedLimitRange');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedLimitRange');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedLimitRange');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/limitranges/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedPersistentVolumeClaim
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedPersistentVolumeClaim($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedPersistentVolumeClaimWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedPersistentVolumeClaim');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedPersistentVolumeClaim');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedPersistentVolumeClaim');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedPod($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedPodWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedPodWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedPod');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedPod');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedPodTemplate
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedPodTemplate($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedPodTemplateWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedPodTemplate');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedPodTemplate');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedPodTemplate');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/podtemplates/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedReplicationController
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedReplicationController($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedReplicationControllerWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedReplicationController');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedReplicationController');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedReplicationController');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedResourceQuota
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedResourceQuota($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedResourceQuotaWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedResourceQuota');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedResourceQuota');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedResourceQuota');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedSecret
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedSecret($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedSecretWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedSecret');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedSecret');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedSecret');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/secrets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedService($name, $namespace, $pretty = null)
    {
        list($response) = $this->deleteCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedService');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1NamespacedServiceAccount
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1NamespacedServiceAccount($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NamespacedServiceAccountWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1NamespacedServiceAccount');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling deleteCoreV1NamespacedServiceAccount');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1NamespacedServiceAccount');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1Node
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1Node($name, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1NodeWithHttpInfo($name, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1NodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1NodeWithHttpInfo($name, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1Node');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1Node');
        }

        $resourcePath = '/api/v1/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1PersistentVolume
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1PersistentVolume($name, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1PersistentVolumeWithHttpInfo($name, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1PersistentVolumeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1PersistentVolumeWithHttpInfo($name, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1PersistentVolume');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1PersistentVolume');
        }

        $resourcePath = '/api/v1/persistentvolumes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation deleteCoreV1SecurityContextConstraints
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Status
     */
    public function deleteCoreV1SecurityContextConstraints($name, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        list($response) = $this->deleteCoreV1SecurityContextConstraintsWithHttpInfo($name, $body, $pretty, $gracePeriodSeconds, $orphanDependents, $propagationPolicy);
        return $response;
    }

    /**
     * Operation deleteCoreV1SecurityContextConstraintsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1DeleteOptions $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param int $gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param bool $orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param string $propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCoreV1SecurityContextConstraintsWithHttpInfo($name, $body, $pretty = null, $gracePeriodSeconds = null, $orphanDependents = null, $propagationPolicy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteCoreV1SecurityContextConstraints');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling deleteCoreV1SecurityContextConstraints');
        }

        $resourcePath = '/api/v1/securitycontextconstraints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Status';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($gracePeriodSeconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($gracePeriodSeconds);
        }
        // query params
        if ($orphanDependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphanDependents);
        }
        // query params
        if ($propagationPolicy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagationPolicy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Status', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation getCoreV1APIResources
     *
     * 
     *
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1APIResourceList
     */
    public function getCoreV1APIResources()
    {
        list($response) = $this->getCoreV1APIResourcesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getCoreV1APIResourcesWithHttpInfo
     *
     * 
     *
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1APIResourceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCoreV1APIResourcesWithHttpInfo()
    {

        $resourcePath = '/api/v1/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1APIResourceList';



        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1APIResourceList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1ComponentStatus
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ComponentStatusList
     */
    public function listCoreV1ComponentStatus($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1ComponentStatusWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1ComponentStatusWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ComponentStatusList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1ComponentStatusWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/componentstatuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ComponentStatusList';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ComponentStatusList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1ConfigMapForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ConfigMapList
     */
    public function listCoreV1ConfigMapForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1ConfigMapForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1ConfigMapForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ConfigMapList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1ConfigMapForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/configmaps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMapList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMapList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1EndpointsForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1EndpointsList
     */
    public function listCoreV1EndpointsForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1EndpointsForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1EndpointsForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1EndpointsList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1EndpointsForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/endpoints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1EndpointsList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1EndpointsList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1EventForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1EventList
     */
    public function listCoreV1EventForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1EventForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1EventForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1EventList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1EventForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1EventList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1EventList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1LimitRangeForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1LimitRangeList
     */
    public function listCoreV1LimitRangeForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1LimitRangeForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1LimitRangeForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1LimitRangeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1LimitRangeForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/limitranges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1LimitRangeList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1LimitRangeList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1Namespace
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1NamespaceList
     */
    public function listCoreV1Namespace($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespaceWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespaceWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1NamespaceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespaceWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/namespaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1NamespaceList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1NamespaceList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedConfigMap
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ConfigMapList
     */
    public function listCoreV1NamespacedConfigMap($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedConfigMapWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedConfigMapWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ConfigMapList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedConfigMapWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedConfigMap');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/configmaps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMapList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMapList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedEndpoints
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1EndpointsList
     */
    public function listCoreV1NamespacedEndpoints($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedEndpointsWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedEndpointsWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1EndpointsList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedEndpointsWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedEndpoints');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/endpoints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1EndpointsList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1EndpointsList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedEvent
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1EventList
     */
    public function listCoreV1NamespacedEvent($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedEventWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedEventWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1EventList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedEventWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedEvent');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1EventList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1EventList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedLimitRange
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1LimitRangeList
     */
    public function listCoreV1NamespacedLimitRange($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedLimitRangeWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedLimitRangeWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1LimitRangeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedLimitRangeWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedLimitRange');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/limitranges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1LimitRangeList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1LimitRangeList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedPersistentVolumeClaim
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaimList
     */
    public function listCoreV1NamespacedPersistentVolumeClaim($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedPersistentVolumeClaimWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaimList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedPersistentVolumeClaim');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaimList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaimList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedPod
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PodList
     */
    public function listCoreV1NamespacedPod($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedPodWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PodList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedPodWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedPod');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PodList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PodList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedPodTemplate
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PodTemplateList
     */
    public function listCoreV1NamespacedPodTemplate($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedPodTemplateWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedPodTemplateWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PodTemplateList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedPodTemplateWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedPodTemplate');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/podtemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplateList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplateList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedReplicationController
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationControllerList
     */
    public function listCoreV1NamespacedReplicationController($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedReplicationControllerWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedReplicationControllerWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationControllerList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedReplicationControllerWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedReplicationController');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationControllerList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationControllerList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedResourceQuota
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuotaList
     */
    public function listCoreV1NamespacedResourceQuota($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedResourceQuotaWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedResourceQuotaWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuotaList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedResourceQuotaWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedResourceQuota');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuotaList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuotaList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedSecret
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1SecretList
     */
    public function listCoreV1NamespacedSecret($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedSecretWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedSecretWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1SecretList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedSecretWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedSecret');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1SecretList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1SecretList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedService
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ServiceList
     */
    public function listCoreV1NamespacedService($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedServiceWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ServiceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedServiceWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedService');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ServiceList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ServiceList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1NamespacedServiceAccount
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccountList
     */
    public function listCoreV1NamespacedServiceAccount($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NamespacedServiceAccountWithHttpInfo($namespace, $pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NamespacedServiceAccountWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccountList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NamespacedServiceAccountWithHttpInfo($namespace, $pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling listCoreV1NamespacedServiceAccount');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/serviceaccounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccountList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccountList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1Node
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1NodeList
     */
    public function listCoreV1Node($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1NodeWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1NodeWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1NodeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1NodeWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1NodeList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1NodeList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1PersistentVolume
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeList
     */
    public function listCoreV1PersistentVolume($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1PersistentVolumeWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1PersistentVolumeWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1PersistentVolumeWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/persistentvolumes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1PersistentVolumeClaimForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaimList
     */
    public function listCoreV1PersistentVolumeClaimForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1PersistentVolumeClaimForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1PersistentVolumeClaimForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaimList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1PersistentVolumeClaimForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/persistentvolumeclaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaimList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaimList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1PodForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PodList
     */
    public function listCoreV1PodForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1PodForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1PodForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PodList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1PodForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/pods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PodList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PodList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1PodTemplateForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PodTemplateList
     */
    public function listCoreV1PodTemplateForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1PodTemplateForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1PodTemplateForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PodTemplateList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1PodTemplateForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/podtemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplateList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplateList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1ReplicationControllerForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationControllerList
     */
    public function listCoreV1ReplicationControllerForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1ReplicationControllerForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1ReplicationControllerForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationControllerList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1ReplicationControllerForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/replicationcontrollers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationControllerList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationControllerList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1ResourceQuotaForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuotaList
     */
    public function listCoreV1ResourceQuotaForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1ResourceQuotaForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1ResourceQuotaForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuotaList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1ResourceQuotaForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/resourcequotas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuotaList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuotaList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1SecretForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1SecretList
     */
    public function listCoreV1SecretForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1SecretForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1SecretForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1SecretList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1SecretForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1SecretList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1SecretList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1SecurityContextConstraints
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraintsList
     */
    public function listCoreV1SecurityContextConstraints($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1SecurityContextConstraintsWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1SecurityContextConstraintsWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraintsList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1SecurityContextConstraintsWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/securitycontextconstraints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraintsList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraintsList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1ServiceAccountForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccountList
     */
    public function listCoreV1ServiceAccountForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1ServiceAccountForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1ServiceAccountForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccountList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1ServiceAccountForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/serviceaccounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccountList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccountList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation listCoreV1ServiceForAllNamespaces
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ServiceList
     */
    public function listCoreV1ServiceForAllNamespaces($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->listCoreV1ServiceForAllNamespacesWithHttpInfo($pretty, $fieldSelector, $labelSelector, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation listCoreV1ServiceForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ServiceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCoreV1ServiceForAllNamespacesWithHttpInfo($pretty = null, $fieldSelector = null, $labelSelector = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ServiceList';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ServiceList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1Namespace
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Namespace
     */
    public function patchCoreV1Namespace($name, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespaceWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespaceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Namespace, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespaceWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1Namespace');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1Namespace');
        }

        $resourcePath = '/api/v1/namespaces/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Namespace';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Namespace', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespaceStatus
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Namespace
     */
    public function patchCoreV1NamespaceStatus($name, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespaceStatusWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespaceStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Namespace, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespaceStatusWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespaceStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespaceStatus');
        }

        $resourcePath = '/api/v1/namespaces/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Namespace';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Namespace', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedConfigMap
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap
     */
    public function patchCoreV1NamespacedConfigMap($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedConfigMapWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedConfigMap');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedConfigMap');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedConfigMap');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/configmaps/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedEndpoints
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Endpoints
     */
    public function patchCoreV1NamespacedEndpoints($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedEndpointsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Endpoints, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedEndpoints');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedEndpoints');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedEndpoints');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/endpoints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedEvent
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Event
     */
    public function patchCoreV1NamespacedEvent($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedEventWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedEventWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Event, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedEventWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedEvent');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedEvent');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedEvent');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/events/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Event';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Event', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedLimitRange
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1LimitRange
     */
    public function patchCoreV1NamespacedLimitRange($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedLimitRangeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1LimitRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedLimitRange');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedLimitRange');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedLimitRange');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/limitranges/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedPersistentVolumeClaim
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim
     */
    public function patchCoreV1NamespacedPersistentVolumeClaim($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedPersistentVolumeClaimWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedPersistentVolumeClaim');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedPersistentVolumeClaim');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedPersistentVolumeClaim');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedPersistentVolumeClaimStatus
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim
     */
    public function patchCoreV1NamespacedPersistentVolumeClaimStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedPersistentVolumeClaimStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedPersistentVolumeClaimStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedPersistentVolumeClaimStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedPersistentVolumeClaimStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedPersistentVolumeClaimStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedPersistentVolumeClaimStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Pod
     */
    public function patchCoreV1NamespacedPod($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedPodWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Pod, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedPodWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedPod');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedPod');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Pod';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Pod', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedPodStatus
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Pod
     */
    public function patchCoreV1NamespacedPodStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedPodStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedPodStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Pod, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedPodStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedPodStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedPodStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedPodStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Pod';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Pod', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedPodTemplate
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate
     */
    public function patchCoreV1NamespacedPodTemplate($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedPodTemplateWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedPodTemplate');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedPodTemplate');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedPodTemplate');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/podtemplates/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedReplicationController
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController
     */
    public function patchCoreV1NamespacedReplicationController($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedReplicationControllerWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedReplicationController');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedReplicationController');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedReplicationController');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedReplicationControllerStatus
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController
     */
    public function patchCoreV1NamespacedReplicationControllerStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedReplicationControllerStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedReplicationControllerStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedReplicationControllerStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedReplicationControllerStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedReplicationControllerStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedReplicationControllerStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedResourceQuota
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota
     */
    public function patchCoreV1NamespacedResourceQuota($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedResourceQuotaWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedResourceQuota');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedResourceQuota');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedResourceQuota');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedResourceQuotaStatus
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota
     */
    public function patchCoreV1NamespacedResourceQuotaStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedResourceQuotaStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedResourceQuotaStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedResourceQuotaStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedResourceQuotaStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedResourceQuotaStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedResourceQuotaStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedScaleScale
     *
     * 
     *
     * @param string $name name of the Scale (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Scale
     */
    public function patchCoreV1NamespacedScaleScale($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedScaleScaleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedScaleScaleWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Scale (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedScaleScaleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedScaleScale');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedScaleScale');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedScaleScale');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Scale';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Scale', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedSecret
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Secret
     */
    public function patchCoreV1NamespacedSecret($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedSecretWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Secret, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedSecret');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedSecret');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedSecret');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/secrets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Secret';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Secret', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Service
     */
    public function patchCoreV1NamespacedService($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedService');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedService');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Service';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Service', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedServiceAccount
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount
     */
    public function patchCoreV1NamespacedServiceAccount($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedServiceAccountWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedServiceAccount');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedServiceAccount');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedServiceAccount');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NamespacedServiceStatus
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Service
     */
    public function patchCoreV1NamespacedServiceStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NamespacedServiceStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NamespacedServiceStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NamespacedServiceStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NamespacedServiceStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling patchCoreV1NamespacedServiceStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NamespacedServiceStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Service';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Service', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1Node
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Node
     */
    public function patchCoreV1Node($name, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NodeWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NodeWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1Node');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1Node');
        }

        $resourcePath = '/api/v1/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Node';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Node', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1NodeStatus
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Node
     */
    public function patchCoreV1NodeStatus($name, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1NodeStatusWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1NodeStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1NodeStatusWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1NodeStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1NodeStatus');
        }

        $resourcePath = '/api/v1/nodes/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Node';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Node', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1PersistentVolume
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume
     */
    public function patchCoreV1PersistentVolume($name, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1PersistentVolumeWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1PersistentVolumeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1PersistentVolumeWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1PersistentVolume');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1PersistentVolume');
        }

        $resourcePath = '/api/v1/persistentvolumes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1PersistentVolumeStatus
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume
     */
    public function patchCoreV1PersistentVolumeStatus($name, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1PersistentVolumeStatusWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1PersistentVolumeStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1PersistentVolumeStatusWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1PersistentVolumeStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1PersistentVolumeStatus');
        }

        $resourcePath = '/api/v1/persistentvolumes/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation patchCoreV1SecurityContextConstraints
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints
     */
    public function patchCoreV1SecurityContextConstraints($name, $body, $pretty = null)
    {
        list($response) = $this->patchCoreV1SecurityContextConstraintsWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchCoreV1SecurityContextConstraintsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Patch $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchCoreV1SecurityContextConstraintsWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling patchCoreV1SecurityContextConstraints');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling patchCoreV1SecurityContextConstraints');
        }

        $resourcePath = '/api/v1/securitycontextconstraints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1DELETENamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1DELETENamespacedPod($name, $namespace)
    {
        list($response) = $this->proxyCoreV1DELETENamespacedPodWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1DELETENamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1DELETENamespacedPodWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1DELETENamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1DELETENamespacedPod');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1DELETENamespacedPodWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1DELETENamespacedPodWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1DELETENamespacedPodWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1DELETENamespacedPodWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1DELETENamespacedPodWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1DELETENamespacedPodWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1DELETENamespacedPodWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1DELETENamespacedPodWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1DELETENamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1DELETENamespacedService($name, $namespace)
    {
        list($response) = $this->proxyCoreV1DELETENamespacedServiceWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1DELETENamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1DELETENamespacedServiceWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1DELETENamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1DELETENamespacedService');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1DELETENamespacedServiceWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1DELETENamespacedServiceWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1DELETENamespacedServiceWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1DELETENamespacedServiceWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1DELETENamespacedServiceWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1DELETENamespacedServiceWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1DELETENamespacedServiceWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1DELETENamespacedServiceWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1DELETENode
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1DELETENode($name)
    {
        list($response) = $this->proxyCoreV1DELETENodeWithHttpInfo($name);
        return $response;
    }

    /**
     * Operation proxyCoreV1DELETENodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1DELETENodeWithHttpInfo($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1DELETENode');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1DELETENodeWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1DELETENodeWithPath($name, $path)
    {
        list($response) = $this->proxyCoreV1DELETENodeWithPathWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1DELETENodeWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1DELETENodeWithPathWithHttpInfo($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1DELETENodeWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1DELETENodeWithPath');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'DELETE',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1GETNamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1GETNamespacedPod($name, $namespace)
    {
        list($response) = $this->proxyCoreV1GETNamespacedPodWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1GETNamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1GETNamespacedPodWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1GETNamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1GETNamespacedPod');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1GETNamespacedPodWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1GETNamespacedPodWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1GETNamespacedPodWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1GETNamespacedPodWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1GETNamespacedPodWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1GETNamespacedPodWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1GETNamespacedPodWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1GETNamespacedPodWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1GETNamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1GETNamespacedService($name, $namespace)
    {
        list($response) = $this->proxyCoreV1GETNamespacedServiceWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1GETNamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1GETNamespacedServiceWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1GETNamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1GETNamespacedService');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1GETNamespacedServiceWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1GETNamespacedServiceWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1GETNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1GETNamespacedServiceWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1GETNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1GETNamespacedServiceWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1GETNamespacedServiceWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1GETNamespacedServiceWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1GETNode
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1GETNode($name)
    {
        list($response) = $this->proxyCoreV1GETNodeWithHttpInfo($name);
        return $response;
    }

    /**
     * Operation proxyCoreV1GETNodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1GETNodeWithHttpInfo($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1GETNode');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1GETNodeWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1GETNodeWithPath($name, $path)
    {
        list($response) = $this->proxyCoreV1GETNodeWithPathWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1GETNodeWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1GETNodeWithPathWithHttpInfo($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1GETNodeWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1GETNodeWithPath');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1HEADNamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1HEADNamespacedPod($name, $namespace)
    {
        list($response) = $this->proxyCoreV1HEADNamespacedPodWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1HEADNamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1HEADNamespacedPodWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1HEADNamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1HEADNamespacedPod');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1HEADNamespacedPodWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1HEADNamespacedPodWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1HEADNamespacedPodWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1HEADNamespacedPodWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1HEADNamespacedPodWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1HEADNamespacedPodWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1HEADNamespacedPodWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1HEADNamespacedPodWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1HEADNamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1HEADNamespacedService($name, $namespace)
    {
        list($response) = $this->proxyCoreV1HEADNamespacedServiceWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1HEADNamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1HEADNamespacedServiceWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1HEADNamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1HEADNamespacedService');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1HEADNamespacedServiceWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1HEADNamespacedServiceWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1HEADNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1HEADNamespacedServiceWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1HEADNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1HEADNamespacedServiceWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1HEADNamespacedServiceWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1HEADNamespacedServiceWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1HEADNode
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1HEADNode($name)
    {
        list($response) = $this->proxyCoreV1HEADNodeWithHttpInfo($name);
        return $response;
    }

    /**
     * Operation proxyCoreV1HEADNodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1HEADNodeWithHttpInfo($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1HEADNode');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1HEADNodeWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1HEADNodeWithPath($name, $path)
    {
        list($response) = $this->proxyCoreV1HEADNodeWithPathWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1HEADNodeWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1HEADNodeWithPathWithHttpInfo($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1HEADNodeWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1HEADNodeWithPath');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'HEAD',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1OPTIONSNamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1OPTIONSNamespacedPod($name, $namespace)
    {
        list($response) = $this->proxyCoreV1OPTIONSNamespacedPodWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1OPTIONSNamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1OPTIONSNamespacedPodWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1OPTIONSNamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1OPTIONSNamespacedPod');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1OPTIONSNamespacedPodWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1OPTIONSNamespacedPodWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1OPTIONSNamespacedPodWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1OPTIONSNamespacedPodWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1OPTIONSNamespacedPodWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1OPTIONSNamespacedPodWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1OPTIONSNamespacedPodWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1OPTIONSNamespacedPodWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1OPTIONSNamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1OPTIONSNamespacedService($name, $namespace)
    {
        list($response) = $this->proxyCoreV1OPTIONSNamespacedServiceWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1OPTIONSNamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1OPTIONSNamespacedServiceWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1OPTIONSNamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1OPTIONSNamespacedService');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1OPTIONSNamespacedServiceWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1OPTIONSNamespacedServiceWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1OPTIONSNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1OPTIONSNamespacedServiceWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1OPTIONSNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1OPTIONSNamespacedServiceWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1OPTIONSNamespacedServiceWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1OPTIONSNamespacedServiceWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1OPTIONSNode
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1OPTIONSNode($name)
    {
        list($response) = $this->proxyCoreV1OPTIONSNodeWithHttpInfo($name);
        return $response;
    }

    /**
     * Operation proxyCoreV1OPTIONSNodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1OPTIONSNodeWithHttpInfo($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1OPTIONSNode');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1OPTIONSNodeWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1OPTIONSNodeWithPath($name, $path)
    {
        list($response) = $this->proxyCoreV1OPTIONSNodeWithPathWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1OPTIONSNodeWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1OPTIONSNodeWithPathWithHttpInfo($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1OPTIONSNodeWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1OPTIONSNodeWithPath');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'OPTIONS',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PATCHNamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PATCHNamespacedPod($name, $namespace)
    {
        list($response) = $this->proxyCoreV1PATCHNamespacedPodWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1PATCHNamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PATCHNamespacedPodWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PATCHNamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1PATCHNamespacedPod');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PATCHNamespacedPodWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PATCHNamespacedPodWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1PATCHNamespacedPodWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1PATCHNamespacedPodWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PATCHNamespacedPodWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PATCHNamespacedPodWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1PATCHNamespacedPodWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1PATCHNamespacedPodWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PATCHNamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PATCHNamespacedService($name, $namespace)
    {
        list($response) = $this->proxyCoreV1PATCHNamespacedServiceWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1PATCHNamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PATCHNamespacedServiceWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PATCHNamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1PATCHNamespacedService');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PATCHNamespacedServiceWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PATCHNamespacedServiceWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1PATCHNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1PATCHNamespacedServiceWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PATCHNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PATCHNamespacedServiceWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1PATCHNamespacedServiceWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1PATCHNamespacedServiceWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PATCHNode
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PATCHNode($name)
    {
        list($response) = $this->proxyCoreV1PATCHNodeWithHttpInfo($name);
        return $response;
    }

    /**
     * Operation proxyCoreV1PATCHNodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PATCHNodeWithHttpInfo($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PATCHNode');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PATCHNodeWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PATCHNodeWithPath($name, $path)
    {
        list($response) = $this->proxyCoreV1PATCHNodeWithPathWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1PATCHNodeWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PATCHNodeWithPathWithHttpInfo($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PATCHNodeWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1PATCHNodeWithPath');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PATCH',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1POSTNamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1POSTNamespacedPod($name, $namespace)
    {
        list($response) = $this->proxyCoreV1POSTNamespacedPodWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1POSTNamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1POSTNamespacedPodWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1POSTNamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1POSTNamespacedPod');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1POSTNamespacedPodWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1POSTNamespacedPodWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1POSTNamespacedPodWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1POSTNamespacedPodWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1POSTNamespacedPodWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1POSTNamespacedPodWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1POSTNamespacedPodWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1POSTNamespacedPodWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1POSTNamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1POSTNamespacedService($name, $namespace)
    {
        list($response) = $this->proxyCoreV1POSTNamespacedServiceWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1POSTNamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1POSTNamespacedServiceWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1POSTNamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1POSTNamespacedService');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1POSTNamespacedServiceWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1POSTNamespacedServiceWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1POSTNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1POSTNamespacedServiceWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1POSTNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1POSTNamespacedServiceWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1POSTNamespacedServiceWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1POSTNamespacedServiceWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1POSTNode
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1POSTNode($name)
    {
        list($response) = $this->proxyCoreV1POSTNodeWithHttpInfo($name);
        return $response;
    }

    /**
     * Operation proxyCoreV1POSTNodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1POSTNodeWithHttpInfo($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1POSTNode');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1POSTNodeWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1POSTNodeWithPath($name, $path)
    {
        list($response) = $this->proxyCoreV1POSTNodeWithPathWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1POSTNodeWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1POSTNodeWithPathWithHttpInfo($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1POSTNodeWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1POSTNodeWithPath');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'POST',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PUTNamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PUTNamespacedPod($name, $namespace)
    {
        list($response) = $this->proxyCoreV1PUTNamespacedPodWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1PUTNamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PUTNamespacedPodWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PUTNamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1PUTNamespacedPod');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PUTNamespacedPodWithPath
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PUTNamespacedPodWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1PUTNamespacedPodWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1PUTNamespacedPodWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PUTNamespacedPodWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PUTNamespacedPodWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1PUTNamespacedPodWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1PUTNamespacedPodWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PUTNamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PUTNamespacedService($name, $namespace)
    {
        list($response) = $this->proxyCoreV1PUTNamespacedServiceWithHttpInfo($name, $namespace);
        return $response;
    }

    /**
     * Operation proxyCoreV1PUTNamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PUTNamespacedServiceWithHttpInfo($name, $namespace)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PUTNamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1PUTNamespacedService');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PUTNamespacedServiceWithPath
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PUTNamespacedServiceWithPath($name, $namespace, $path)
    {
        list($response) = $this->proxyCoreV1PUTNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1PUTNamespacedServiceWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PUTNamespacedServiceWithPathWithHttpInfo($name, $namespace, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PUTNamespacedServiceWithPath');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling proxyCoreV1PUTNamespacedServiceWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1PUTNamespacedServiceWithPath');
        }

        $resourcePath = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PUTNode
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PUTNode($name)
    {
        list($response) = $this->proxyCoreV1PUTNodeWithHttpInfo($name);
        return $response;
    }

    /**
     * Operation proxyCoreV1PUTNodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PUTNodeWithHttpInfo($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PUTNode');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation proxyCoreV1PUTNodeWithPath
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function proxyCoreV1PUTNodeWithPath($name, $path)
    {
        list($response) = $this->proxyCoreV1PUTNodeWithPathWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation proxyCoreV1PUTNodeWithPathWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $path path to the resource (required)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function proxyCoreV1PUTNodeWithPathWithHttpInfo($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling proxyCoreV1PUTNodeWithPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling proxyCoreV1PUTNodeWithPath');
        }

        $resourcePath = '/api/v1/proxy/nodes/{name}/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';


        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace('{' . 'path' . '}', ObjectSerializer::toPathValue($path), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1ComponentStatus
     *
     * 
     *
     * @param string $name name of the ComponentStatus (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ComponentStatus
     */
    public function readCoreV1ComponentStatus($name, $pretty = null)
    {
        list($response) = $this->readCoreV1ComponentStatusWithHttpInfo($name, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1ComponentStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ComponentStatus (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ComponentStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1ComponentStatusWithHttpInfo($name, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1ComponentStatus');
        }

        $resourcePath = '/api/v1/componentstatuses/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ComponentStatus';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ComponentStatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1Namespace
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Namespace
     */
    public function readCoreV1Namespace($name, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespaceWithHttpInfo($name, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespaceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Namespace, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespaceWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1Namespace');
        }

        $resourcePath = '/api/v1/namespaces/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Namespace';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Namespace', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespaceStatus
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Namespace
     */
    public function readCoreV1NamespaceStatus($name, $pretty = null)
    {
        list($response) = $this->readCoreV1NamespaceStatusWithHttpInfo($name, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1NamespaceStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Namespace, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespaceStatusWithHttpInfo($name, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespaceStatus');
        }

        $resourcePath = '/api/v1/namespaces/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Namespace';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Namespace', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedConfigMap
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap
     */
    public function readCoreV1NamespacedConfigMap($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedConfigMapWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedConfigMap');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedConfigMap');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/configmaps/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedEndpoints
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Endpoints
     */
    public function readCoreV1NamespacedEndpoints($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedEndpointsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Endpoints, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedEndpoints');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedEndpoints');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/endpoints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedEvent
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Event
     */
    public function readCoreV1NamespacedEvent($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedEventWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedEventWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Event, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedEventWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedEvent');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedEvent');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/events/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Event';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Event', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedLimitRange
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1LimitRange
     */
    public function readCoreV1NamespacedLimitRange($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedLimitRangeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1LimitRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedLimitRange');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedLimitRange');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/limitranges/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedPersistentVolumeClaim
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim
     */
    public function readCoreV1NamespacedPersistentVolumeClaim($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedPersistentVolumeClaimWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedPersistentVolumeClaim');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedPersistentVolumeClaim');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedPersistentVolumeClaimStatus
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim
     */
    public function readCoreV1NamespacedPersistentVolumeClaimStatus($name, $namespace, $pretty = null)
    {
        list($response) = $this->readCoreV1NamespacedPersistentVolumeClaimStatusWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedPersistentVolumeClaimStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedPersistentVolumeClaimStatusWithHttpInfo($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedPersistentVolumeClaimStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedPersistentVolumeClaimStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Pod
     */
    public function readCoreV1NamespacedPod($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedPodWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Pod, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedPodWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedPod');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Pod';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Pod', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedPodLog
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $container The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)
     * @param bool $follow Follow the log stream of the pod. Defaults to false. (optional)
     * @param int $limitBytes If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $previous Return previous terminated container logs. Defaults to false. (optional)
     * @param int $sinceSeconds A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)
     * @param int $tailLines If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)
     * @param bool $timestamps If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function readCoreV1NamespacedPodLog($name, $namespace, $container = null, $follow = null, $limitBytes = null, $pretty = null, $previous = null, $sinceSeconds = null, $tailLines = null, $timestamps = null)
    {
        list($response) = $this->readCoreV1NamespacedPodLogWithHttpInfo($name, $namespace, $container, $follow, $limitBytes, $pretty, $previous, $sinceSeconds, $tailLines, $timestamps);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedPodLogWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $container The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)
     * @param bool $follow Follow the log stream of the pod. Defaults to false. (optional)
     * @param int $limitBytes If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $previous Return previous terminated container logs. Defaults to false. (optional)
     * @param int $sinceSeconds A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)
     * @param int $tailLines If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)
     * @param bool $timestamps If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedPodLogWithHttpInfo($name, $namespace, $container = null, $follow = null, $limitBytes = null, $pretty = null, $previous = null, $sinceSeconds = null, $tailLines = null, $timestamps = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedPodLog');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedPodLog');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = 'string';

        // query params
        if ($container !== null) {
            $queryParams['container'] = ObjectSerializer::toQueryValue($container);
        }
        // query params
        if ($follow !== null) {
            $queryParams['follow'] = ObjectSerializer::toQueryValue($follow);
        }
        // query params
        if ($limitBytes !== null) {
            $queryParams['limitBytes'] = ObjectSerializer::toQueryValue($limitBytes);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($previous !== null) {
            $queryParams['previous'] = ObjectSerializer::toQueryValue($previous);
        }
        // query params
        if ($sinceSeconds !== null) {
            $queryParams['sinceSeconds'] = ObjectSerializer::toQueryValue($sinceSeconds);
        }
        // query params
        if ($tailLines !== null) {
            $queryParams['tailLines'] = ObjectSerializer::toQueryValue($tailLines);
        }
        // query params
        if ($timestamps !== null) {
            $queryParams['timestamps'] = ObjectSerializer::toQueryValue($timestamps);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedPodStatus
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Pod
     */
    public function readCoreV1NamespacedPodStatus($name, $namespace, $pretty = null)
    {
        list($response) = $this->readCoreV1NamespacedPodStatusWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedPodStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Pod, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedPodStatusWithHttpInfo($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedPodStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedPodStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Pod';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Pod', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedPodTemplate
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate
     */
    public function readCoreV1NamespacedPodTemplate($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedPodTemplateWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedPodTemplate');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedPodTemplate');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/podtemplates/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedReplicationController
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController
     */
    public function readCoreV1NamespacedReplicationController($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedReplicationControllerWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedReplicationController');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedReplicationController');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedReplicationControllerStatus
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController
     */
    public function readCoreV1NamespacedReplicationControllerStatus($name, $namespace, $pretty = null)
    {
        list($response) = $this->readCoreV1NamespacedReplicationControllerStatusWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedReplicationControllerStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedReplicationControllerStatusWithHttpInfo($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedReplicationControllerStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedReplicationControllerStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedResourceQuota
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota
     */
    public function readCoreV1NamespacedResourceQuota($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedResourceQuotaWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedResourceQuota');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedResourceQuota');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedResourceQuotaStatus
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota
     */
    public function readCoreV1NamespacedResourceQuotaStatus($name, $namespace, $pretty = null)
    {
        list($response) = $this->readCoreV1NamespacedResourceQuotaStatusWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedResourceQuotaStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedResourceQuotaStatusWithHttpInfo($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedResourceQuotaStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedResourceQuotaStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedScaleScale
     *
     * 
     *
     * @param string $name name of the Scale (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Scale
     */
    public function readCoreV1NamespacedScaleScale($name, $namespace, $pretty = null)
    {
        list($response) = $this->readCoreV1NamespacedScaleScaleWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedScaleScaleWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Scale (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedScaleScaleWithHttpInfo($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedScaleScale');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedScaleScale');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Scale';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Scale', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedSecret
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Secret
     */
    public function readCoreV1NamespacedSecret($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedSecretWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Secret, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedSecret');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedSecret');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/secrets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Secret';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Secret', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Service
     */
    public function readCoreV1NamespacedService($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedService');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Service';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Service', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedServiceAccount
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount
     */
    public function readCoreV1NamespacedServiceAccount($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedServiceAccountWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedServiceAccount');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedServiceAccount');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NamespacedServiceStatus
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Service
     */
    public function readCoreV1NamespacedServiceStatus($name, $namespace, $pretty = null)
    {
        list($response) = $this->readCoreV1NamespacedServiceStatusWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1NamespacedServiceStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NamespacedServiceStatusWithHttpInfo($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NamespacedServiceStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling readCoreV1NamespacedServiceStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Service';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Service', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1Node
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Node
     */
    public function readCoreV1Node($name, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1NodeWithHttpInfo($name, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1NodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NodeWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1Node');
        }

        $resourcePath = '/api/v1/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Node';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Node', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1NodeStatus
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Node
     */
    public function readCoreV1NodeStatus($name, $pretty = null)
    {
        list($response) = $this->readCoreV1NodeStatusWithHttpInfo($name, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1NodeStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1NodeStatusWithHttpInfo($name, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1NodeStatus');
        }

        $resourcePath = '/api/v1/nodes/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Node';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Node', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1PersistentVolume
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume
     */
    public function readCoreV1PersistentVolume($name, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1PersistentVolumeWithHttpInfo($name, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1PersistentVolumeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1PersistentVolumeWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1PersistentVolume');
        }

        $resourcePath = '/api/v1/persistentvolumes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1PersistentVolumeStatus
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume
     */
    public function readCoreV1PersistentVolumeStatus($name, $pretty = null)
    {
        list($response) = $this->readCoreV1PersistentVolumeStatusWithHttpInfo($name, $pretty);
        return $response;
    }

    /**
     * Operation readCoreV1PersistentVolumeStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1PersistentVolumeStatusWithHttpInfo($name, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1PersistentVolumeStatus');
        }

        $resourcePath = '/api/v1/persistentvolumes/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation readCoreV1SecurityContextConstraints
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints
     */
    public function readCoreV1SecurityContextConstraints($name, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readCoreV1SecurityContextConstraintsWithHttpInfo($name, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readCoreV1SecurityContextConstraintsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCoreV1SecurityContextConstraintsWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling readCoreV1SecurityContextConstraints');
        }

        $resourcePath = '/api/v1/securitycontextconstraints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1Namespace
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Namespace $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Namespace
     */
    public function replaceCoreV1Namespace($name, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespaceWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespaceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Namespace $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Namespace, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespaceWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1Namespace');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1Namespace');
        }

        $resourcePath = '/api/v1/namespaces/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Namespace';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Namespace', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespaceFinalize
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Namespace $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Namespace
     */
    public function replaceCoreV1NamespaceFinalize($name, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespaceFinalizeWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespaceFinalizeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Namespace $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Namespace, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespaceFinalizeWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespaceFinalize');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespaceFinalize');
        }

        $resourcePath = '/api/v1/namespaces/{name}/finalize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Namespace';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Namespace', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespaceStatus
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Namespace $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Namespace
     */
    public function replaceCoreV1NamespaceStatus($name, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespaceStatusWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespaceStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Namespace $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Namespace, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespaceStatusWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespaceStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespaceStatus');
        }

        $resourcePath = '/api/v1/namespaces/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Namespace';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Namespace', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedConfigMap
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap
     */
    public function replaceCoreV1NamespacedConfigMap($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedConfigMapWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ConfigMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedConfigMap');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedConfigMap');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedConfigMap');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/configmaps/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ConfigMap', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedEndpoints
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Endpoints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Endpoints
     */
    public function replaceCoreV1NamespacedEndpoints($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedEndpointsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Endpoints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Endpoints, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedEndpoints');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedEndpoints');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedEndpoints');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/endpoints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Endpoints', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedEvent
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Event $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Event
     */
    public function replaceCoreV1NamespacedEvent($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedEventWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedEventWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Event $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Event, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedEventWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedEvent');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedEvent');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedEvent');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/events/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Event';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Event', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedLimitRange
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1LimitRange $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1LimitRange
     */
    public function replaceCoreV1NamespacedLimitRange($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedLimitRangeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1LimitRange $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1LimitRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedLimitRange');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedLimitRange');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedLimitRange');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/limitranges/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1LimitRange', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedPersistentVolumeClaim
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim
     */
    public function replaceCoreV1NamespacedPersistentVolumeClaim($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedPersistentVolumeClaimWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedPersistentVolumeClaim');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedPersistentVolumeClaim');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedPersistentVolumeClaim');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedPersistentVolumeClaimStatus
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim
     */
    public function replaceCoreV1NamespacedPersistentVolumeClaimStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedPersistentVolumeClaimStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedPersistentVolumeClaimStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedPersistentVolumeClaimStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolumeClaim', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Pod $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Pod
     */
    public function replaceCoreV1NamespacedPod($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedPodWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Pod $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Pod, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedPodWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedPod');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedPod');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Pod';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Pod', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedPodStatus
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Pod $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Pod
     */
    public function replaceCoreV1NamespacedPodStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedPodStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedPodStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Pod $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Pod, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedPodStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedPodStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedPodStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedPodStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/pods/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Pod';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Pod', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedPodTemplate
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate
     */
    public function replaceCoreV1NamespacedPodTemplate($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedPodTemplateWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PodTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedPodTemplate');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedPodTemplate');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedPodTemplate');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/podtemplates/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PodTemplate', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedReplicationController
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController
     */
    public function replaceCoreV1NamespacedReplicationController($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedReplicationControllerWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedReplicationController');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedReplicationController');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedReplicationController');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedReplicationControllerStatus
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController
     */
    public function replaceCoreV1NamespacedReplicationControllerStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedReplicationControllerStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedReplicationControllerStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ReplicationController, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedReplicationControllerStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedReplicationControllerStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedReplicationControllerStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedReplicationControllerStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ReplicationController', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedResourceQuota
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota
     */
    public function replaceCoreV1NamespacedResourceQuota($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedResourceQuotaWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedResourceQuota');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedResourceQuota');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedResourceQuota');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedResourceQuotaStatus
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota
     */
    public function replaceCoreV1NamespacedResourceQuotaStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedResourceQuotaStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedResourceQuotaStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedResourceQuotaStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedResourceQuotaStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedResourceQuotaStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedResourceQuotaStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ResourceQuota', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedScaleScale
     *
     * 
     *
     * @param string $name name of the Scale (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Scale $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Scale
     */
    public function replaceCoreV1NamespacedScaleScale($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedScaleScaleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedScaleScaleWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Scale (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Scale $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedScaleScaleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedScaleScale');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedScaleScale');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedScaleScale');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Scale';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Scale', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedSecret
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Secret $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Secret
     */
    public function replaceCoreV1NamespacedSecret($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedSecretWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Secret $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Secret, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedSecret');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedSecret');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedSecret');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/secrets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Secret';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Secret', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Service $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Service
     */
    public function replaceCoreV1NamespacedService($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Service $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedService');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedService');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Service';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Service', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedServiceAccount
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount
     */
    public function replaceCoreV1NamespacedServiceAccount($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedServiceAccountWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedServiceAccount');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedServiceAccount');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedServiceAccount');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1ServiceAccount', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NamespacedServiceStatus
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Service $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Service
     */
    public function replaceCoreV1NamespacedServiceStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NamespacedServiceStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NamespacedServiceStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Service $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NamespacedServiceStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NamespacedServiceStatus');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling replaceCoreV1NamespacedServiceStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NamespacedServiceStatus');
        }

        $resourcePath = '/api/v1/namespaces/{namespace}/services/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Service';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Service', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1Node
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Node $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Node
     */
    public function replaceCoreV1Node($name, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NodeWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Node $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NodeWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1Node');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1Node');
        }

        $resourcePath = '/api/v1/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Node';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Node', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1NodeStatus
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Node $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1Node
     */
    public function replaceCoreV1NodeStatus($name, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1NodeStatusWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1NodeStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1Node $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1NodeStatusWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1NodeStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1NodeStatus');
        }

        $resourcePath = '/api/v1/nodes/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1Node';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1Node', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1PersistentVolume
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume
     */
    public function replaceCoreV1PersistentVolume($name, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1PersistentVolumeWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1PersistentVolumeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1PersistentVolumeWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1PersistentVolume');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1PersistentVolume');
        }

        $resourcePath = '/api/v1/persistentvolumes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1PersistentVolumeStatus
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume
     */
    public function replaceCoreV1PersistentVolumeStatus($name, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1PersistentVolumeStatusWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1PersistentVolumeStatusWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1PersistentVolumeStatusWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1PersistentVolumeStatus');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1PersistentVolumeStatus');
        }

        $resourcePath = '/api/v1/persistentvolumes/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1PersistentVolume', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation replaceCoreV1SecurityContextConstraints
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints
     */
    public function replaceCoreV1SecurityContextConstraints($name, $body, $pretty = null)
    {
        list($response) = $this->replaceCoreV1SecurityContextConstraintsWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceCoreV1SecurityContextConstraintsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints $body  (required)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceCoreV1SecurityContextConstraintsWithHttpInfo($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling replaceCoreV1SecurityContextConstraints');
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling replaceCoreV1SecurityContextConstraints');
        }

        $resourcePath = '/api/v1/securitycontextconstraints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints';

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'PUT',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1SecurityContextConstraints', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1ConfigMapListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1ConfigMapListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1ConfigMapListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1ConfigMapListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1ConfigMapListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/configmaps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1EndpointsListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1EndpointsListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1EndpointsListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1EndpointsListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1EndpointsListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/endpoints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1EventListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1EventListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1EventListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1EventListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1EventListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1LimitRangeListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1LimitRangeListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1LimitRangeListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1LimitRangeListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1LimitRangeListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/limitranges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1Namespace
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1Namespace($name, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespaceWithHttpInfo($name, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespaceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Namespace (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespaceWithHttpInfo($name, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1Namespace');
        }

        $resourcePath = '/api/v1/watch/namespaces/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespaceList
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespaceList($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespaceListWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespaceListWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespaceListWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/namespaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedConfigMap
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedConfigMap($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedConfigMapWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ConfigMap (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedConfigMapWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedConfigMap');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedConfigMap');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/configmaps/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedConfigMapList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedConfigMapList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedConfigMapListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedConfigMapListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedConfigMapListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedConfigMapList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/configmaps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedEndpoints
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedEndpoints($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedEndpointsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Endpoints (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedEndpointsWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedEndpoints');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedEndpoints');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/endpoints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedEndpointsList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedEndpointsList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedEndpointsListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedEndpointsListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedEndpointsListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedEndpointsList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/endpoints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedEvent
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedEvent($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedEventWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedEventWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Event (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedEventWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedEvent');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedEvent');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/events/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedEventList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedEventList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedEventListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedEventListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedEventListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedEventList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedLimitRange
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedLimitRange($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedLimitRangeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the LimitRange (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedLimitRangeWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedLimitRange');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedLimitRange');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/limitranges/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedLimitRangeList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedLimitRangeList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedLimitRangeListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedLimitRangeListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedLimitRangeListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedLimitRangeList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/limitranges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedPersistentVolumeClaim
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedPersistentVolumeClaim($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedPersistentVolumeClaimWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolumeClaim (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedPersistentVolumeClaimWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedPersistentVolumeClaim');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedPersistentVolumeClaim');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedPersistentVolumeClaimList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedPersistentVolumeClaimList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedPersistentVolumeClaimListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedPersistentVolumeClaimListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedPersistentVolumeClaimListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedPersistentVolumeClaimList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedPod
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedPod($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedPodWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedPodWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Pod (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedPodWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedPod');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedPod');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/pods/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedPodList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedPodList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedPodListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedPodListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedPodListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedPodList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/pods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedPodTemplate
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedPodTemplate($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedPodTemplateWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PodTemplate (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedPodTemplateWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedPodTemplate');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedPodTemplate');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/podtemplates/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedPodTemplateList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedPodTemplateList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedPodTemplateListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedPodTemplateListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedPodTemplateListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedPodTemplateList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/podtemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedReplicationController
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedReplicationController($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedReplicationControllerWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ReplicationController (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedReplicationControllerWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedReplicationController');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedReplicationController');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedReplicationControllerList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedReplicationControllerList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedReplicationControllerListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedReplicationControllerListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedReplicationControllerListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedReplicationControllerList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/replicationcontrollers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedResourceQuota
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedResourceQuota($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedResourceQuotaWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ResourceQuota (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedResourceQuotaWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedResourceQuota');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedResourceQuota');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedResourceQuotaList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedResourceQuotaList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedResourceQuotaListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedResourceQuotaListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedResourceQuotaListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedResourceQuotaList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/resourcequotas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedSecret
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedSecret($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedSecretWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Secret (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedSecretWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedSecret');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedSecret');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/secrets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedSecretList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedSecretList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedSecretListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedSecretListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedSecretListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedSecretList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedService
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedService($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedServiceWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Service (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedServiceWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedService');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedService');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/services/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedServiceAccount
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedServiceAccount($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedServiceAccountWithHttpInfo
     *
     * 
     *
     * @param string $name name of the ServiceAccount (required)
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedServiceAccountWithHttpInfo($name, $namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1NamespacedServiceAccount');
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedServiceAccount');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedServiceAccountList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedServiceAccountList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedServiceAccountListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedServiceAccountListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedServiceAccountListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedServiceAccountList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/serviceaccounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NamespacedServiceList
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NamespacedServiceList($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NamespacedServiceListWithHttpInfo($namespace, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NamespacedServiceListWithHttpInfo
     *
     * 
     *
     * @param string $namespace object name and auth scope, such as for teams and projects (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NamespacedServiceListWithHttpInfo($namespace, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException('Missing the required parameter $namespace when calling watchCoreV1NamespacedServiceList');
        }

        $resourcePath = '/api/v1/watch/namespaces/{namespace}/services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace('{' . 'namespace' . '}', ObjectSerializer::toPathValue($namespace), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1Node
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1Node($name, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NodeWithHttpInfo($name, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NodeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the Node (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NodeWithHttpInfo($name, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1Node');
        }

        $resourcePath = '/api/v1/watch/nodes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1NodeList
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1NodeList($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1NodeListWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1NodeListWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1NodeListWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1PersistentVolume
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1PersistentVolume($name, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1PersistentVolumeWithHttpInfo($name, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1PersistentVolumeWithHttpInfo
     *
     * 
     *
     * @param string $name name of the PersistentVolume (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1PersistentVolumeWithHttpInfo($name, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1PersistentVolume');
        }

        $resourcePath = '/api/v1/watch/persistentvolumes/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1PersistentVolumeClaimListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1PersistentVolumeClaimListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1PersistentVolumeClaimListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1PersistentVolumeClaimListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1PersistentVolumeClaimListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/persistentvolumeclaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1PersistentVolumeList
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1PersistentVolumeList($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1PersistentVolumeListWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1PersistentVolumeListWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1PersistentVolumeListWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/persistentvolumes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1PodListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1PodListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1PodListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1PodListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1PodListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/pods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1PodTemplateListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1PodTemplateListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1PodTemplateListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1PodTemplateListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1PodTemplateListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/podtemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1ReplicationControllerListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1ReplicationControllerListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1ReplicationControllerListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1ReplicationControllerListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1ReplicationControllerListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/replicationcontrollers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1ResourceQuotaListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1ResourceQuotaListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1ResourceQuotaListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1ResourceQuotaListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1ResourceQuotaListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/resourcequotas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1SecretListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1SecretListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1SecretListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1SecretListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1SecretListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1SecurityContextConstraints
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1SecurityContextConstraints($name, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1SecurityContextConstraintsWithHttpInfo($name, $fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1SecurityContextConstraintsWithHttpInfo
     *
     * 
     *
     * @param string $name name of the SecurityContextConstraints (required)
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1SecurityContextConstraintsWithHttpInfo($name, $fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling watchCoreV1SecurityContextConstraints');
        }

        $resourcePath = '/api/v1/watch/securitycontextconstraints/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace('{' . 'name' . '}', ObjectSerializer::toPathValue($name), $resourcePath);
        }

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1SecurityContextConstraintsList
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1SecurityContextConstraintsList($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1SecurityContextConstraintsListWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1SecurityContextConstraintsListWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1SecurityContextConstraintsListWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/securitycontextconstraints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1ServiceAccountListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1ServiceAccountListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1ServiceAccountListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1ServiceAccountListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1ServiceAccountListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/serviceaccounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
    /**
     * Operation watchCoreV1ServiceListForAllNamespaces
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent
     */
    public function watchCoreV1ServiceListForAllNamespaces($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {
        list($response) = $this->watchCoreV1ServiceListForAllNamespacesWithHttpInfo($fieldSelector, $labelSelector, $pretty, $resourceVersion, $timeoutSeconds, $watch);
        return $response;
    }

    /**
     * Operation watchCoreV1ServiceListForAllNamespacesWithHttpInfo
     *
     * 
     *
     * @param string $fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param string $labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param string $resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param int $timeoutSeconds Timeout for the list/watch call. (optional)
     * @param bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     * @throws \UniversityOfAdelaide\OpenShift\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \UniversityOfAdelaide\OpenShift\Model\V1WatchEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchCoreV1ServiceListForAllNamespacesWithHttpInfo($fieldSelector = null, $labelSelector = null, $pretty = null, $resourceVersion = null, $timeoutSeconds = null, $watch = null)
    {

        $resourcePath = '/api/v1/watch/services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $returnType = '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent';

        // query params
        if ($fieldSelector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($fieldSelector);
        }
        // query params
        if ($labelSelector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($labelSelector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resourceVersion !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resourceVersion);
        }
        // query params
        if ($timeoutSeconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeoutSeconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                $httpBody = new MultipartStream($multipartContents); // for HTTP post (form)

            } else {
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams); // for HTTP post (form)
            }
        }

        if ($httpBody instanceof MultipartStream) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }


        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $url = $this->config->getHost() . $resourcePath . ($query ? '?' . $query : '');

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $request = new Request(
            'GET',
            $url,
            $headers,
            $httpBody
        );

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    "[$statusCode] Error connecting to the API ($url)",
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\UniversityOfAdelaide\OpenShift\Model\V1WatchEvent', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }
}
